// Generated by zerobufCxx.py
#pragma once
#include <zerobuf/ConstVector.h>
#include <zerobuf/NonMovingAllocator.h>
#include <zerobuf/Vector.h>
#include <zerobuf/Zerobuf.h>

namespace zeq
{
namespace hbp
{
template< class Alloc = zerobuf::NonMovingAllocator >
class CameraBase : public zerobuf::Zerobuf
{
public:
    typedef ::zerobuf::Vector< float, 0 > Matrix;
    typedef ::zerobuf::ConstVector< float, 0 > ConstMatrix;
    typename CameraBase< Alloc >::Matrix getMatrix();
    typename CameraBase< Alloc >::ConstMatrix getMatrix() const;
    void setMatrix( float const * value, size_t size );
    std::string getMatrixString() const;
    void setMatrix( const std::string& value );

    bool readJSON( const std::string& json );

    CameraBase();
    CameraBase( const CameraBase& from );
    virtual ~CameraBase() {}

    CameraBase< Alloc >& operator = ( const CameraBase& rhs );
    static bool isEmptyZerobuf() { return false; }
    static bool isStaticZerobuf() { return false; }

    virtual servus::uint128_t getZerobufType() const
    { return servus::uint128_t( 0xe42466dec2d7ab81ull, 0xefefcb2ed1b4df3bull ); }

private:
    template< class T > void _setZerobufArray( const T* data, const size_t size, const size_t arrayNum );
};

typedef CameraBase< ::zerobuf::NonMovingAllocator > Camera;

}
}
