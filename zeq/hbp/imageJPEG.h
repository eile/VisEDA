// Generated by zerobufCxx.py
#pragma once
#include <zerobuf/ConstVector.h>
#include <zerobuf/NonMovingAllocator.h>
#include <zerobuf/Vector.h>
#include <zerobuf/Zerobuf.h>

namespace zeq
{
namespace hbp
{
template< class Alloc = zerobuf::NonMovingAllocator >
class ImageJPEGBase : public zerobuf::Zerobuf
{
public:
    typedef ::zerobuf::Vector< uint8_t, 0 > Data;
    typedef ::zerobuf::ConstVector< uint8_t, 0 > ConstData;
    typename ImageJPEGBase< Alloc >::Data getData();
    typename ImageJPEGBase< Alloc >::ConstData getData() const;
    void setData( uint8_t const * value, size_t size );
    std::string getDataString() const;
    void setData( const std::string& value );

    bool readJSON( const std::string& json );

    ImageJPEGBase();
    ImageJPEGBase( const ImageJPEGBase& from );
    virtual ~ImageJPEGBase() {}

    ImageJPEGBase< Alloc >& operator = ( const ImageJPEGBase& rhs );
    static bool isEmptyZerobuf() { return false; }
    static bool isStaticZerobuf() { return false; }

    virtual servus::uint128_t getZerobufType() const
    { return servus::uint128_t( 0xbebed8a37dcc1af8ull, 0x95c5215b745d1507ull ); }

private:
    template< class T > void _setZerobufArray( const T* data, const size_t size, const size_t arrayNum );
};

typedef ImageJPEGBase< ::zerobuf::NonMovingAllocator > ImageJPEG;

}
}
