// Generated by zerobufCxx.py
#pragma once
#include <zerobuf/ConstVector.h>
#include <zerobuf/NonMovingAllocator.h>
#include <zerobuf/Vector.h>
#include <zerobuf/Zerobuf.h>

namespace zeq
{
namespace vocabulary
{
enum Direction
{
    Direction_Subscriber,
    Direction_Publisher,
    Direction_Both,
};

template< class Alloc = zerobuf::NonMovingAllocator >
class DictionaryBase : public zerobuf::Zerobuf
{
public:
    typedef ::zerobuf::Vector< char*, 0 > RestNames;
    typedef ::zerobuf::ConstVector< char*, 0 > ConstRestNames;
    typename DictionaryBase< Alloc >::RestNames getRestNames();
    typename DictionaryBase< Alloc >::ConstRestNames getRestNames() const;
    void setRestNames( char* const * value, size_t size );
    std::string getRestNamesString() const;
    void setRestNames( const std::string& value );

    typedef ::zerobuf::Vector< servus::uint128_t, 1 > Events;
    typedef ::zerobuf::ConstVector< servus::uint128_t, 1 > ConstEvents;
    typename DictionaryBase< Alloc >::Events getEvents();
    typename DictionaryBase< Alloc >::ConstEvents getEvents() const;
    void setEvents( servus::uint128_t const * value, size_t size );
    std::string getEventsString() const;
    void setEvents( const std::string& value );

    typedef ::zerobuf::Vector< Direction, 2 > Directions;
    typedef ::zerobuf::ConstVector< Direction, 2 > ConstDirections;
    typename DictionaryBase< Alloc >::Directions getDirections();
    typename DictionaryBase< Alloc >::ConstDirections getDirections() const;
    void setDirections( Direction const * value, size_t size );
    std::string getDirectionsString() const;
    void setDirections( const std::string& value );

    typedef ::zerobuf::Vector< char*, 3 > Schemas;
    typedef ::zerobuf::ConstVector< char*, 3 > ConstSchemas;
    typename DictionaryBase< Alloc >::Schemas getSchemas();
    typename DictionaryBase< Alloc >::ConstSchemas getSchemas() const;
    void setSchemas( char* const * value, size_t size );
    std::string getSchemasString() const;
    void setSchemas( const std::string& value );

    bool readJSON( const std::string& json );

    DictionaryBase();
    DictionaryBase( const DictionaryBase& from );
    virtual ~DictionaryBase() {}

    DictionaryBase< Alloc >& operator = ( const DictionaryBase& rhs );
    static bool isEmptyZerobuf() { return false; }
    static bool isStaticZerobuf() { return false; }

    virtual servus::uint128_t getZerobufType() const
    { return servus::uint128_t( 0x83637cd812dcdfe9ull, 0x03187b75006256ccull ); }

private:
    template< class T > void _setZerobufArray( const T* data, const size_t size, const size_t arrayNum );
};

typedef DictionaryBase< ::zerobuf::NonMovingAllocator > Dictionary;

}
}
