// Generated by zerobufCxx.py
#pragma once
#include <zerobuf/ConstVector.h>
#include <zerobuf/NonMovingAllocator.h>
#include <zerobuf/Vector.h>
#include <zerobuf/Zerobuf.h>

namespace zeq
{
namespace vocabulary
{
template< class Alloc = zerobuf::NonMovingAllocator >
class EchoBase : public zerobuf::Zerobuf
{
public:
    typedef ::zerobuf::Vector< char, 0 > Message;
    typedef ::zerobuf::ConstVector< char, 0 > ConstMessage;
    typename EchoBase< Alloc >::Message getMessage();
    typename EchoBase< Alloc >::ConstMessage getMessage() const;
    void setMessage( char const * value, size_t size );
    std::string getMessageString() const;
    void setMessage( const std::string& value );

    bool readJSON( const std::string& json );

    EchoBase();
    EchoBase( const EchoBase& from );
    virtual ~EchoBase() {}

    EchoBase< Alloc >& operator = ( const EchoBase& rhs );
    static bool isEmptyZerobuf() { return false; }
    static bool isStaticZerobuf() { return false; }

    virtual servus::uint128_t getZerobufType() const
    { return servus::uint128_t( 0xce329f5564b1b77cull, 0xac7c47ee3f58e26cull ); }

private:
    template< class T > void _setZerobufArray( const T* data, const size_t size, const size_t arrayNum );
};

typedef EchoBase< ::zerobuf::NonMovingAllocator > Echo;

}
}
