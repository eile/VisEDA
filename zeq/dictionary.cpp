// Generated by zerobufCxx.py
#include "dictionary.h"
#include <zerobuf/jsoncpp/json/json.h>
#include <iostream>

namespace zeq
{
namespace vocabulary
{
template< class Alloc >
typename DictionaryBase< Alloc >::RestNames DictionaryBase< Alloc >::getRestNames()
{
    return RestNames( getAllocator( ));
}

template< class Alloc >
typename DictionaryBase< Alloc >::ConstRestNames DictionaryBase< Alloc >::getRestNames() const
{
    return ConstRestNames( getAllocator( ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setRestNames( char* const * value, size_t size )
{
    _setZerobufArray( value, size * sizeof( char* ), 0 );
}

template< class Alloc >
std::string DictionaryBase< Alloc >::getRestNamesString() const
{
    const uint8_t* ptr = getAllocator()->template getDynamic< const uint8_t >( 0 );
    return std::string( ptr, ptr + getAllocator()->template getItem< uint64_t >( 12 ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setRestNames( const std::string& value )
{
    _setZerobufArray( value.c_str(), value.length(), 0 );
}


template< class Alloc >
typename DictionaryBase< Alloc >::Events DictionaryBase< Alloc >::getEvents()
{
    return Events( getAllocator( ));
}

template< class Alloc >
typename DictionaryBase< Alloc >::ConstEvents DictionaryBase< Alloc >::getEvents() const
{
    return ConstEvents( getAllocator( ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setEvents( servus::uint128_t const * value, size_t size )
{
    _setZerobufArray( value, size * sizeof( servus::uint128_t ), 1 );
}

template< class Alloc >
std::string DictionaryBase< Alloc >::getEventsString() const
{
    const uint8_t* ptr = getAllocator()->template getDynamic< const uint8_t >( 1 );
    return std::string( ptr, ptr + getAllocator()->template getItem< uint64_t >( 28 ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setEvents( const std::string& value )
{
    _setZerobufArray( value.c_str(), value.length(), 1 );
}


template< class Alloc >
typename DictionaryBase< Alloc >::Directions DictionaryBase< Alloc >::getDirections()
{
    return Directions( getAllocator( ));
}

template< class Alloc >
typename DictionaryBase< Alloc >::ConstDirections DictionaryBase< Alloc >::getDirections() const
{
    return ConstDirections( getAllocator( ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setDirections( Direction const * value, size_t size )
{
    _setZerobufArray( value, size * sizeof( Direction ), 2 );
}

template< class Alloc >
std::string DictionaryBase< Alloc >::getDirectionsString() const
{
    const uint8_t* ptr = getAllocator()->template getDynamic< const uint8_t >( 2 );
    return std::string( ptr, ptr + getAllocator()->template getItem< uint64_t >( 44 ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setDirections( const std::string& value )
{
    _setZerobufArray( value.c_str(), value.length(), 2 );
}


template< class Alloc >
typename DictionaryBase< Alloc >::Schemas DictionaryBase< Alloc >::getSchemas()
{
    return Schemas( getAllocator( ));
}

template< class Alloc >
typename DictionaryBase< Alloc >::ConstSchemas DictionaryBase< Alloc >::getSchemas() const
{
    return ConstSchemas( getAllocator( ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setSchemas( char* const * value, size_t size )
{
    _setZerobufArray( value, size * sizeof( char* ), 3 );
}

template< class Alloc >
std::string DictionaryBase< Alloc >::getSchemasString() const
{
    const uint8_t* ptr = getAllocator()->template getDynamic< const uint8_t >( 3 );
    return std::string( ptr, ptr + getAllocator()->template getItem< uint64_t >( 60 ));
}

template< class Alloc >
void DictionaryBase< Alloc >::setSchemas( const std::string& value )
{
    _setZerobufArray( value.c_str(), value.length(), 3 );
}


template< class Alloc >
bool DictionaryBase< Alloc >::readJSON( const std::string& json )
{
    Json::Value dict;
    if( !_parseJSON( json, dict ))
        return false;

    if( dict.isMember( "restNames" ))
        std::cout << "restNames" << ':' << dict[ "restNames" ].toStyledString() << std::endl;
    if( dict.isMember( "events" ))
        std::cout << "events" << ':' << dict[ "events" ].toStyledString() << std::endl;
    if( dict.isMember( "directions" ))
        std::cout << "directions" << ':' << dict[ "directions" ].toStyledString() << std::endl;
    if( dict.isMember( "schemas" ))
        std::cout << "schemas" << ':' << dict[ "schemas" ].toStyledString() << std::endl;
    return true;
}

template< class Alloc >
DictionaryBase< Alloc >::DictionaryBase()
    : zerobuf::Zerobuf( new Alloc( 68, 4 ))
{}


template< class Alloc >
DictionaryBase< Alloc >::DictionaryBase( const DictionaryBase& from )
    : zerobuf::Zerobuf( new Alloc( *static_cast< const Alloc* >( from.getAllocator( ))))
{}

template< class Alloc >
DictionaryBase< Alloc >& DictionaryBase< Alloc >::operator = ( const DictionaryBase& rhs )
{
    ::zerobuf::Zerobuf::operator = ( rhs );
    return *this;
}

template< class Alloc >
template< class T > void DictionaryBase< Alloc >::_setZerobufArray( const T* data, const size_t size, const size_t arrayNum )
{
    void* array = getAllocator()->updateAllocation( arrayNum, size );
    ::memcpy( array, data, size );
}


template class DictionaryBase< ::zerobuf::NonMovingAllocator >;
}
}
